{% extends "base.html" %}

{% block title %}Stats - GeoGuessr Dashboard{% endblock %}

{% block content %}
<h1>GeoGuessr Statistics</h1>

<div id="filters">
    <div class="filter-group">
        <label for="gameType">Game Type:</label>
        <select id="gameType">
            <option value="duels">Solo Duels</option>
            <option value="team_duels">Team Duels</option>
        </select>
    </div>
    <div class="filter-group">
        <label for="mode">Mode:</label>
        <select id="mode">
            <option value="all">All Games</option>
            <option value="competitive">Competitive</option>
            <option value="casual">Casual</option>
        </select>
    </div>
    <div class="filter-group" id="teammate-filter" style="display: none;">
        <label for="teammate">Teammate:</label>
        <select id="teammate">
            <option value="">All Teammates</option>
        </select>
    </div>
    <div class="filter-group">
        <label for="sortBy">Sort Countries By:</label>
        <select id="sortBy">
            <option value="score_diff">Score Diff (Recommended)</option>
            <option value="avg_score">Average Score</option>
            <option value="win_rate">Win Rate</option>
            <option value="hit_rate">Hit Rate</option>
        </select>
    </div>
</div>

<div id="loading">Loading stats...</div>
<div id="no-stats" style="display: none;">
    <p>No stats found for this filter. <a href="{{ url_for('show_fetch') }}">Fetch some games first</a>.</p>
</div>

<div id="stats-container" style="display: none;">
    <section id="overall-stats">
        <h2>Overall Stats</h2>
        <div class="stats-grid" id="overall-grid"></div>
    </section>

    <section id="player-contributions" style="display: none;">
        <h2>Player Contributions</h2>
        <div id="contributions-grid"></div>
    </section>

    <section id="country-stats">
        <h2>Country Performance</h2>

        <div class="country-section">
            <h3>Top 10 Countries <span id="top-sort-label">(by Score Diff)</span></h3>
            <table id="top-countries">
                <thead>
                    <tr>
                        <th>Country</th>
                        <th>Rounds</th>
                        <th>Avg Score</th>
                        <th>Score Diff</th>
                        <th>Win Rate</th>
                        <th>Hit Rate</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>

        <div class="country-section">
            <h3>Bottom 10 Countries <span id="bottom-sort-label">(by Score Diff)</span></h3>
            <table id="bottom-countries">
                <thead>
                    <tr>
                        <th>Country</th>
                        <th>Rounds</th>
                        <th>Avg Score</th>
                        <th>Score Diff</th>
                        <th>Win Rate</th>
                        <th>Hit Rate</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
    </section>

    <section id="world-map-section">
        <h2>World Map</h2>
        <p class="map-legend" id="map-legend">
            <span class="legend-item"><span class="legend-color score-3"></span> +200+</span>
            <span class="legend-item"><span class="legend-color score-2"></span> +100 to +200</span>
            <span class="legend-item"><span class="legend-color score-1"></span> 0 to +100</span>
            <span class="legend-item"><span class="legend-color score--1"></span> -100 to 0</span>
            <span class="legend-item"><span class="legend-color score--2"></span> -200 to -100</span>
            <span class="legend-item"><span class="legend-color score--3"></span> -200-</span>
            <span class="legend-item"><span class="legend-color unplayed"></span> No Data</span>
        </p>
        <div id="map-container">
            <p id="map-loading">Loading map...</p>
        </div>
    </section>
</div>
{% endblock %}

{% block scripts %}
<script>
const gameTypeSelect = document.getElementById('gameType');
const modeSelect = document.getElementById('mode');
const teammateSelect = document.getElementById('teammate');
const teammateFilter = document.getElementById('teammate-filter');
const sortBySelect = document.getElementById('sortBy');

// Sort option display names
const sortLabels = {
    'score_diff': 'Score Diff',
    'avg_score': 'Avg Score',
    'win_rate': 'Win Rate',
    'hit_rate': 'Hit Rate'
};

// Map metric configurations: field name, thresholds (ascending), and legend labels
const metricConfigs = {
    'score_diff': {
        field: 'avg_score_diff',
        // Thresholds: values below t[0] get score--3, between t[0]-t[1] get score--2, etc.
        thresholds: [-200, -100, 0, 100, 200],
        legend: ['+200+', '+100 to +200', '0 to +100', '-100 to 0', '-200 to -100', '-200-']
    },
    'avg_score': {
        field: 'avg_score',
        // 5000 is perfect, 0 is worst. Divide into 6 equal sections (~833 each)
        thresholds: [833, 1667, 2500, 3333, 4167],
        legend: ['4167+', '3333 to 4167', '2500 to 3333', '1667 to 2500', '833 to 1667', '0 to 833']
    },
    'win_rate': {
        field: 'win_rate',
        // Stored as 0-1, divide into ~17% sections
        thresholds: [0.17, 0.33, 0.50, 0.67, 0.83],
        legend: ['83%+', '67% to 83%', '50% to 67%', '33% to 50%', '17% to 33%', '0% to 17%']
    },
    'hit_rate': {
        field: 'hit_rate',
        // Stored as 0-1, divide into ~17% sections
        thresholds: [0.17, 0.33, 0.50, 0.67, 0.83],
        legend: ['83%+', '67% to 83%', '50% to 67%', '33% to 50%', '17% to 33%', '0% to 17%']
    }
};

// Store countries data for map coloring
let allCountriesData = [];
let mapLoaded = false;

// Parse URL params for initial filter state
const urlParams = new URLSearchParams(window.location.search);
const initialGameType = urlParams.get('game_type') || 'duels';
const initialMode = urlParams.get('mode') || 'all';
const initialTeammate = urlParams.get('teammate') || '';
const initialSortBy = urlParams.get('sort') || 'score_diff';

// Load the SVG map on page load
async function loadWorldMap() {
    const container = document.getElementById('map-container');
    try {
        const response = await fetch('/static/svg/world-map.svg');
        if (!response.ok) throw new Error('Failed to load map');
        const svgText = await response.text();
        container.innerHTML = svgText;
        mapLoaded = true;
        // Color the map if we already have data
        if (allCountriesData.length > 0) {
            updateWorldMap(allCountriesData, sortBySelect.value);
        }
    } catch (err) {
        container.innerHTML = '<p class="error">Could not load map</p>';
        console.error('Error loading map:', err);
    }
}

function updateMapLegend(sortBy) {
    const config = metricConfigs[sortBy] || metricConfigs['score_diff'];
    const legendEl = document.getElementById('map-legend');

    legendEl.innerHTML = `
        <span class="legend-item"><span class="legend-color score-3"></span> ${config.legend[0]}</span>
        <span class="legend-item"><span class="legend-color score-2"></span> ${config.legend[1]}</span>
        <span class="legend-item"><span class="legend-color score-1"></span> ${config.legend[2]}</span>
        <span class="legend-item"><span class="legend-color score--1"></span> ${config.legend[3]}</span>
        <span class="legend-item"><span class="legend-color score--2"></span> ${config.legend[4]}</span>
        <span class="legend-item"><span class="legend-color score--3"></span> ${config.legend[5]}</span>
        <span class="legend-item"><span class="legend-color unplayed"></span> No Data</span>
    `;
}

function getColorClass(value, thresholds) {
    // thresholds is an array of 5 values in ascending order
    // Returns score class based on which bucket the value falls into
    if (value >= thresholds[4]) return 'score-3';      // Dark green (best)
    if (value >= thresholds[3]) return 'score-2';      // Medium green
    if (value >= thresholds[2]) return 'score-1';      // Light green
    if (value >= thresholds[1]) return 'score--1';     // Yellow/Gold
    if (value >= thresholds[0]) return 'score--2';     // Orange
    return 'score--3';                                  // Red (worst)
}

function updateWorldMap(countries, sortBy) {
    if (!mapLoaded) return;

    const config = metricConfigs[sortBy] || metricConfigs['score_diff'];

    // Update the legend to match the metric
    updateMapLegend(sortBy);

    // Build lookup by country code (lowercase)
    const countryLookup = {};
    countries.forEach(c => {
        countryLookup[c.country_code.toLowerCase()] = c;
    });

    // Get all elements with IDs in the map (both paths and groups)
    const mapContainer = document.querySelector('#map-container svg');
    if (!mapContainer) return;

    // Process all elements with an id attribute
    const elementsWithId = mapContainer.querySelectorAll('[id]');

    elementsWithId.forEach(element => {
        const code = element.id.toLowerCase();
        // Skip non-country IDs (like "world-map")
        if (code === 'world-map' || code.length > 3) return;

        const stats = countryLookup[code];

        // Get all paths within this element (or the element itself if it's a path)
        const paths = element.tagName === 'path' ? [element] : element.querySelectorAll('path');

        paths.forEach(path => {
            // Reset classes
            path.classList.remove('played', 'score-3', 'score-2', 'score-1', 'score--1', 'score--2', 'score--3');

            if (stats && stats.rounds > 0) {
                path.classList.add('played');

                // Get the value for the current metric and determine color class
                const value = stats[config.field] || 0;
                const colorClass = getColorClass(value, config.thresholds);
                path.classList.add(colorClass);

                // Add click handler
                path.onclick = (e) => {
                    e.stopPropagation();
                    navigateToCountry(code);
                };
            } else {
                // Remove click handler for unplayed countries
                path.onclick = null;
            }
        });
    });
}

function navigateToCountry(countryCode) {
    const gameType = gameTypeSelect.value;
    const mode = modeSelect.value;
    const teammate = teammateSelect.value;
    const sortBy = sortBySelect.value;

    let url = `/countries/${countryCode}/?game_type=${gameType}&mode=${mode}`;
    if (teammate) {
        url += `&teammate=${teammate}`;
    }
    if (sortBy !== 'score_diff') {
        url += `&sort=${sortBy}`;
    }
    window.location.href = url;
}

// Load map on page load
loadWorldMap();

// Load stats when filters change
gameTypeSelect.addEventListener('change', onGameTypeChange);
modeSelect.addEventListener('change', loadStats);
teammateSelect.addEventListener('change', loadStats);
sortBySelect.addEventListener('change', loadStats);

async function onGameTypeChange() {
    const gameType = gameTypeSelect.value;

    if (gameType === 'team_duels') {
        teammateFilter.style.display = 'flex';
        await loadTeammates();
    } else {
        teammateFilter.style.display = 'none';
        teammateSelect.value = '';
    }

    loadStats();
}

async function loadTeammates() {
    try {
        const res = await fetch('/api/v1/teammates/');
        const data = await res.json();

        if (data.success && data.teammates) {
            // Keep "All Teammates" option
            teammateSelect.innerHTML = '<option value="">All Teammates</option>';

            data.teammates.forEach(t => {
                const option = document.createElement('option');
                option.value = t.player_id;
                option.textContent = `${t.username} (${t.games_played} games)`;
                teammateSelect.appendChild(option);
            });
        }
    } catch (err) {
        console.error('Error loading teammates:', err);
    }
}

function updateURLParams() {
    const params = new URLSearchParams();
    params.set('game_type', gameTypeSelect.value);
    params.set('mode', modeSelect.value);
    if (teammateSelect.value) {
        params.set('teammate', teammateSelect.value);
    }
    if (sortBySelect.value !== 'score_diff') {
        params.set('sort', sortBySelect.value);
    }
    const newUrl = `${window.location.pathname}?${params.toString()}`;
    window.history.replaceState({}, '', newUrl);
}

function updateSortLabels() {
    const sortLabel = sortLabels[sortBySelect.value];
    document.getElementById('top-sort-label').textContent = `(by ${sortLabel})`;
    document.getElementById('bottom-sort-label').textContent = `(by ${sortLabel})`;
}

async function loadStats() {
    const loading = document.getElementById('loading');
    const noStats = document.getElementById('no-stats');
    const container = document.getElementById('stats-container');

    const gameType = gameTypeSelect.value;
    const mode = modeSelect.value;
    const teammate = teammateSelect.value;
    const sortBy = sortBySelect.value;

    // Update URL to preserve filter state
    updateURLParams();
    updateSortLabels();

    loading.style.display = 'block';
    noStats.style.display = 'none';
    container.style.display = 'none';

    try {
        // Build query string
        let queryParams = `game_type=${gameType}&mode=${mode}`;
        if (teammate) {
            queryParams += `&teammate=${teammate}`;
        }
        if (sortBy !== 'score_diff') {
            queryParams += `&sort=${sortBy}`;
        }

        // Fetch overall stats with filters
        const statsRes = await fetch(`/api/v1/stats/?${queryParams}`);
        const statsData = await statsRes.json();

        if (!statsData.success) {
            loading.style.display = 'none';
            noStats.style.display = 'block';
            return;
        }

        // Fetch country stats with filters
        const countriesRes = await fetch(`/api/v1/countries/?${queryParams}`);
        const countriesData = await countriesRes.json();

        // Render overall stats
        const overall = statsData.data.overall;
        const overallGrid = document.getElementById('overall-grid');
        overallGrid.innerHTML = `
            <div class="stat-card">
                <h3>Total Games</h3>
                <p>${overall.total_games}</p>
            </div>
            <div class="stat-card">
                <h3>Win Rate</h3>
                <p>${(overall.win_percentage * 100).toFixed(1)}%</p>
            </div>
            <div class="stat-card">
                <h3>Avg Rounds/Game</h3>
                <p>${overall.avg_rounds_per_game.toFixed(2)}</p>
            </div>
            ${overall.avg_score ? `
            <div class="stat-card">
                <h3>Avg Score</h3>
                <p>${overall.avg_score.toFixed(0)}</p>
            </div>` : ''}
            ${overall.total_5ks ? `
            <div class="stat-card">
                <h3>Total 5Ks</h3>
                <p>${overall.total_5ks}</p>
            </div>` : ''}
            ${overall.avg_guess_time ? `
            <div class="stat-card">
                <h3>Avg Guess Time</h3>
                <p>${overall.avg_guess_time.toFixed(1)}s</p>
            </div>` : ''}
            <div class="stat-card">
                <h3>Multi-Merchanted</h3>
                <p>${overall.multi_merchant}</p>
            </div>
            <div class="stat-card">
                <h3>Reverse Merchanted</h3>
                <p>${overall.reverse_merchant}</p>
            </div>
        `;

        // Render player contributions if available
        const contributions = statsData.data.player_contributions;
        const contribSection = document.getElementById('player-contributions');
        const contribGrid = document.getElementById('contributions-grid');

        if (contributions && contributions.length > 0) {
            contribSection.style.display = 'block';
            contribGrid.innerHTML = contributions.map(p => `
                <div class="player-card">
                    <h4>${p.username || p.player_id}</h4>
                    <p class="games-count">${p.games_played} games</p>
                    <p>Contribution: ${(p.contribution_percent * 100).toFixed(1)}%</p>
                    ${p.avg_individual_score ? `<p>Avg Score: ${p.avg_individual_score.toFixed(0)}</p>` : ''}
                    ${p.total_5ks ? `<p>5Ks: ${p.total_5ks}</p>` : ''}
                    ${p.avg_guess_time ? `<p>Avg Time: ${p.avg_guess_time.toFixed(1)}s</p>` : ''}
                </div>
            `).join('');
        } else {
            contribSection.style.display = 'none';
        }

        // Render country tables and update map
        if (countriesData.success) {
            renderCountryTable('top-countries', countriesData.data.top_10);
            renderCountryTable('bottom-countries', countriesData.data.bottom_10);

            // Store all countries data and update the map
            allCountriesData = countriesData.data.all_countries || [];
            updateWorldMap(allCountriesData, sortBy);
        }

        loading.style.display = 'none';
        container.style.display = 'block';

    } catch (err) {
        loading.innerHTML = `<p class="error">Error loading stats: ${err.message}</p>`;
    }
}

function renderCountryTable(tableId, countries) {
    const tbody = document.querySelector(`#${tableId} tbody`);
    if (!countries || countries.length === 0) {
        tbody.innerHTML = '<tr><td colspan="6">No data available</td></tr>';
        return;
    }
    tbody.innerHTML = countries.map(c => `
        <tr>
            <td>${c.country_code.toUpperCase()}</td>
            <td>${c.rounds}</td>
            <td>${c.avg_score.toFixed(0)}</td>
            <td>${c.avg_score_diff >= 0 ? '+' : ''}${c.avg_score_diff.toFixed(0)}</td>
            <td>${(c.win_rate * 100).toFixed(1)}%</td>
            <td>${(c.hit_rate * 100).toFixed(1)}%</td>
        </tr>
    `).join('');
}

// Initialize filters from URL params and load stats
async function init() {
    // Set initial filter values from URL
    gameTypeSelect.value = initialGameType;
    modeSelect.value = initialMode;
    sortBySelect.value = initialSortBy;

    if (initialGameType === 'team_duels') {
        teammateFilter.style.display = 'flex';
        await loadTeammates();
        if (initialTeammate) {
            teammateSelect.value = initialTeammate;
        }
    }

    loadStats();
}

init();
</script>
{% endblock %}
